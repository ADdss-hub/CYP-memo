# 语义化版本控制规范 (SemVer 2.0.0)

**来源**: [https://semver.org/spec/v2.0.0](https://semver.org/spec/v2.0.0)  
**翻译和整理**: CYP 版本管理系统

---

## 摘要

给定版本号 **MAJOR.MINOR.PATCH**，递增规则如下：

1. **MAJOR** (主版本号): 当你做了不兼容的 API 修改
2. **MINOR** (次版本号): 当你以向后兼容的方式添加功能
3. **PATCH** (修订号): 当你做了向后兼容的问题修正

预发布和构建元数据可作为 MAJOR.MINOR.PATCH 格式的扩展标签。

---

## 语义化版本控制规范

本文档中的关键词 "MUST"（必须）、"MUST NOT"（禁止）、"REQUIRED"（需要）、"SHALL"（将要）、"SHALL NOT"（不应）、"SHOULD"（应该）、"SHOULD NOT"（不应该）、"RECOMMENDED"（推荐）、"MAY"（可以）和 "OPTIONAL"（可选）应按照 RFC 2119 中的描述进行解释。

### 1. 公共 API 声明

使用语义化版本控制的软件**必须（MUST）**声明公共 API。此 API 可以在代码本身中声明，或严格存在于文档中。无论如何，它**应该（SHOULD）**是精确和全面的。

### 2. 版本号格式

正常的版本号**必须（MUST）**采用 X.Y.Z 的形式，其中 X、Y 和 Z 为非负整数，并且**禁止（MUST NOT）**包含前导零。X 是主版本号，Y 是次版本号，Z 是修订号。每个元素**必须（MUST）**以数值递增。

**示例**: 1.9.0 -> 1.10.0 -> 1.11.0

### 3. 版本不可变性

一旦版本化的包已经发布，该版本的内容**禁止（MUST NOT）**被修改。任何修改**必须（MUST）**作为新版本发布。

### 4. 初始开发阶段

主版本号为零（0.y.z）用于初始开发。任何内容**可以（MAY）**随时更改。公共 API **不应该（SHOULD NOT）**被视为稳定。

### 5. 1.0.0 版本

版本 1.0.0 定义了公共 API。此版本发布后版本号的递增方式取决于此公共 API 及其变化方式。

### 6. 修订号递增规则

修订号 Z（x.y.Z | x > 0）**必须（MUST）**在仅引入向后兼容的错误修复时递增。错误修复被定义为修正不正确行为的内部更改。

### 7. 次版本号递增规则

次版本号 Y（x.Y.z | x > 0）**必须（MUST）**在以下情况下递增：

- 向公共 API 引入新的向后兼容功能
- 任何公共 API 功能被标记为弃用

次版本号**可以（MAY）**在以下情况下递增：

- 在私有代码中引入大量新功能或改进
- 包含修订级别的更改

当次版本号递增时，修订号**必须（MUST）**重置为 0。

### 8. 主版本号递增规则

主版本号 X（X.y.z | X > 0）**必须（MUST）**在向公共 API 引入任何向后不兼容的更改时递增。

主版本号**可以（MAY）**包含次版本号和修订号级别的更改。

当主版本号递增时，次版本号和修订号**必须（MUST）**重置为 0。

### 9. 预发布版本

预发布版本**可以（MAY）**通过在修订号后附加连字符和一系列以点分隔的标识符来表示。

**规则**:
- 标识符**必须（MUST）**仅包含 ASCII 字母数字和连字符 [0-9A-Za-z-]
- 标识符**禁止（MUST NOT）**为空
- 数字标识符**禁止（MUST NOT）**包含前导零
- 预发布版本的优先级低于关联的正常版本
- 预发布版本表示该版本不稳定，可能不满足其关联正常版本所表示的预期兼容性要求

**示例**: 
- 1.0.0-alpha
- 1.0.0-alpha.1
- 1.0.0-0.3.7
- 1.0.0-x.7.z.92
- 1.0.0-x-y-z.--

### 10. 构建元数据

构建元数据**可以（MAY）**通过在修订号或预发布版本后附加加号和一系列以点分隔的标识符来表示。

**规则**:
- 标识符**必须（MUST）**仅包含 ASCII 字母数字和连字符 [0-9A-Za-z-]
- 标识符**禁止（MUST NOT）**为空
- 在确定版本优先级时**必须（MUST）**忽略构建元数据
- 仅在构建元数据上不同的两个版本具有相同的优先级

**示例**:
- 1.0.0-alpha+001
- 1.0.0+20130313144700
- 1.0.0-beta+exp.sha.5114f85
- 1.0.0+21AF26D3----117B344092BD

### 11. 版本优先级

优先级是指在排序时如何相互比较版本。

**规则**:

1. **必须（MUST）**通过将版本分为主版本号、次版本号、修订号和预发布标识符来计算优先级（构建元数据不参与优先级计算）

2. 优先级由从左到右比较这些标识符时的第一个差异决定：主版本号、次版本号和修订号始终以数值方式比较
   - 示例: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1

3. 当主版本号、次版本号和修订号相等时，预发布版本的优先级低于正常版本
   - 示例: 1.0.0-alpha < 1.0.0

4. 具有相同主版本号、次版本号和修订号的两个预发布版本的优先级**必须（MUST）**通过从左到右比较每个以点分隔的标识符来确定，直到找到差异：
   - 仅包含数字的标识符以数值方式比较
   - 包含字母或连字符的标识符按 ASCII 排序顺序进行词法比较
   - 数字标识符的优先级始终低于非数字标识符
   - 如果所有前面的标识符都相等，则较大的预发布字段集具有更高的优先级
   - 示例: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0

---

## 常见问题解答

### 1. 在 0.y.z 初始开发阶段应该如何处理修订？

最简单的做法是从 0.1.0 开始初始开发版本，然后为每个后续版本递增次版本号。

### 2. 何时发布 1.0.0？

如果你的软件在生产环境中使用，它应该已经是 1.0.0。如果你有一个用户已经依赖的稳定 API，你应该是 1.0.0。如果你非常担心向后兼容性，你应该已经是 1.0.0。

### 3. 这不会阻碍快速开发和快速迭代吗？

主版本号为零就是为了快速开发。如果你每天都在更改 API，你应该仍然处于版本 0.y.z 或在单独的开发分支上开发下一个主版本。

### 4. 即使是最微小的向后不兼容更改也需要主版本号递增，我不会很快就到达版本 42.0.0 吗？

这是一个负责任的开发和远见的问题。不应该轻易地向具有大量依赖代码的软件引入不兼容的更改。升级所需的成本可能很大。必须递增主版本号来发布不兼容的更改意味着你会仔细考虑更改的影响，并评估所涉及的成本/收益比。

### 5. 记录整个公共 API 工作量太大！

作为专业开发人员，正确记录供他人使用的软件是你的责任。管理软件复杂性是保持项目高效的重要部分，如果没有人知道如何使用你的软件，或者哪些方法可以安全调用，那就很难做到这一点。从长远来看，语义化版本控制和对明确定义的公共 API 的坚持可以让每个人和一切顺利运行。

### 6. 如果我不小心将向后不兼容的更改作为次版本发布了怎么办？

一旦你意识到你违反了语义化版本控制规范，就修复问题并发布一个新的次版本，该版本纠正问题并恢复向后兼容性。即使在这种情况下，修改已版本化的发布也是不可接受的。如果合适，记录有问题的版本并通知用户该问题，以便他们了解有问题的版本。

### 7. 如果我更新自己的依赖项而不更改公共 API，我应该怎么做？

这将被视为兼容的，因为它不影响公共 API。明确依赖于与你的包相同依赖项的软件应该有自己的依赖项规范，作者会注意到任何冲突。确定更改是修订级别还是次版本级别的修改取决于你是为了修复错误还是引入新功能而更新依赖项。我们通常期望后者情况下有额外的代码，在这种情况下，它显然是次版本级别的递增。

### 8. 如果我无意中以不符合版本号更改的方式更改了公共 API（即代码在修订版本中错误地引入了重大破坏性更改）？

使用你的最佳判断。如果你有一个庞大的受众，通过将行为改回公共 API 预期的内容会受到严重影响，那么最好执行主版本发布，即使修复严格来说可以被视为修订版本。记住，语义化版本控制就是通过版本号的变化来传达意义。如果这些更改对你的用户很重要，请使用版本号来通知他们。

### 9. 我应该如何处理弃用功能？

弃用现有功能是软件开发的正常部分，通常需要向前推进。当你弃用公共 API 的一部分时，你应该做两件事：(1) 更新文档让用户知道更改，(2) 发布一个包含弃用的新次版本。在你在新的主版本中完全删除功能之前，应该至少有一个包含弃用的次版本，以便用户可以平滑过渡到新的 API。

### 10. SemVer 对版本字符串的大小有限制吗？

没有，但要使用良好的判断。例如，255 个字符的版本字符串可能过度了。此外，特定系统可能对字符串的大小施加自己的限制。

### 11. "v1.2.3" 是语义化版本吗？

不，"v1.2.3" 不是语义化版本。但是，在语义化版本前加上 "v" 是（在英语中）表示它是版本号的常见方式。将 "version" 缩写为 "v" 在版本控制中经常看到。

**示例**: `git tag v1.2.3 -m "Release version 1.2.3"`，在这种情况下 "v1.2.3" 是标签名称，语义化版本是 "1.2.3"。

---

## SemVer 正则表达式

### 带命名组的正则表达式

适用于支持命名组的系统（PCRE、Python、Go）：

```regex
^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

### 带编号捕获组的正则表达式

适用于 ECMA Script (JavaScript)、PCRE、Python、Go：

```regex
^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

其中：
- cg1 = major (主版本号)
- cg2 = minor (次版本号)
- cg3 = patch (修订号)
- cg4 = prerelease (预发布标识)
- cg5 = buildmetadata (构建元数据)

---

## 关于

语义化版本控制规范最初由 Tom Preston-Werner（Gravatar 的发明者和 GitHub 的联合创始人）编写。

如果你想留下反馈，请在 [GitHub](https://github.com/semver/semver) 上提出问题。

---

## 许可证

Creative Commons ― CC BY 3.0

---

**本文档整理时间**: 2025年12月28日  
**整理人**: CYP 版本管理系统  
**参考来源**: https://semver.org/spec/v2.0.0
