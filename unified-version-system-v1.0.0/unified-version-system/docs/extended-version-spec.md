# 扩展版本规范

本文档基于 [SemVer 2.0.0](https://semver.org/spec/v2.0.0.html) 规范，提供了项目特定的扩展规范和实践指南。

## 版本格式

本项目采用语义化版本控制规范 (SemVer 2.0.0)，版本号格式为 `vMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`：

- **MAJOR** 主版本号：当你做了不兼容的 API 修改时**必须**递增
- **MINOR** 次版本号：当你做了向下兼容的功能性新增时**必须**递增
- **PATCH** 修订号：当你做了向下兼容的问题修正时**必须**递增
- **PRERELEASE** 预发布版本标识（可选）：用连字符分隔的标识符序列
- **BUILD** 构建元数据（可选）：用加号分隔的标识符序列

### 版本号规则（严格遵循 SemVer 2.0.0）

1. 版本号**必须**以 `v` 前缀开头（项目约定）
2. 主版本号、次版本号、修订号**必须**是非负整数
3. 版本号各部分**禁止**前导零（例如：`v01.1.0` 是无效的）
4. 版本号**必须**单调递增
5. 一旦发布，版本内容**禁止**修改，任何修改**必须**发布为新版本

### 预发布版本标识

预发布版本**可以**通过在修订号后添加连字符和一系列点号分隔的标识符来表示：

- `-alpha.N` Alpha 版本（内部测试）
- `-beta.N` Beta 版本（公开测试）
- `-rc.N` 候选版本（Release Candidate）

预发布版本的优先级**低于**相关联的正式版本。

### 构建元数据

构建元数据**可以**通过在修订号或预发布版本后添加加号和一系列点号分隔的标识符来表示：

- `+20130313144700` 时间戳
- `+exp.sha.5114f85` 提交哈希
- `+21AF26D3` 构建编号

构建元数据在判断版本优先级时**应该**被忽略。

### 示例

有效的版本号：
- `v1.0.0` - 正式版本
- `v2.1.3-beta.1` - Beta 预发布版本
- `v3.0.0-alpha.2` - Alpha 预发布版本
- `v1.0.0-rc.1+20130313144700` - 候选版本带构建元数据
- `v2.0.0+21AF26D3` - 正式版本带构建元数据

无效的版本号：
- `1.0.0` - 缺少 `v` 前缀
- `v01.1.0` - 包含前导零
- `v1.2` - 缺少修订号
- `v1.2.3.4` - 版本号部分过多

## 变更类型规范

为了更好地跟踪和管理版本变更，本项目采用[约定式提交（Conventional Commits）](https://www.conventionalcommits.org/)规范来定义变更类型。每条变更记录**必须**包含一个类型，用于指示变更的性质。

### 标准变更类型

根据 SemVer 2.0.0 规范和约定式提交规范，定义以下变更类型：

| 类型       | 说明                         | 对版本号的影响        | SemVer 规则 |
|------------|------------------------------|----------------------|-------------|
| feat       | 新功能                       | MINOR 版本**必须**递增 | 向下兼容的功能性新增 |
| fix        | 修复问题                     | PATCH 版本**必须**递增 | 向下兼容的问题修正 |
| docs       | 文档更新                     | PATCH 版本**应该**递增 | 不影响代码功能 |
| style      | 代码风格更新（不影响功能）   | PATCH 版本**应该**递增 | 不影响代码含义 |
| refactor   | 代码重构（不影响功能）       | PATCH 版本**应该**递增 | 既不修复问题也不添加功能 |
| perf       | 性能优化                     | PATCH 版本**应该**递增 | 提高性能的代码更改 |
| test       | 测试相关                     | PATCH 版本**可以**递增 | 添加或修正测试 |
| build      | 构建系统或外部依赖变更       | PATCH 版本**可以**递增 | 影响构建系统或依赖 |
| ci         | CI 配置文件和脚本变更        | PATCH 版本**可以**递增 | 持续集成配置更改 |
| chore      | 日常维护工作                 | PATCH 版本**可以**递增 | 其他不修改源码的更改 |
| revert     | 回滚之前的提交               | 根据被回滚的提交决定  | 撤销之前的提交 |

### 破坏性变更（BREAKING CHANGE）

根据 SemVer 2.0.0 规范第 8 条：

> 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。

> 1.0.0 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的 API 时，就应该发布 1.0.0 版本。

**破坏性变更规则：**

1. 当你做了不兼容的 API 修改时，**必须**递增主版本号（MAJOR）
2. 破坏性变更**可以**在任何类型的提交中声明
3. 破坏性变更**必须**在提交信息中包含 `BREAKING CHANGE:` 字段
4. 破坏性变更**必须**在变更日志中详细说明

**示例：**

```
feat: 允许配置对象扩展其他配置

BREAKING CHANGE: `extends` 键现在用于扩展其他配置文件
```

| 变更类型 | 说明 | 对版本号的影响 | SemVer 规则 |
|---------|------|---------------|-------------|
| BREAKING CHANGE | 不兼容的 API 修改 | MAJOR 版本**必须**递增 | 引入了不向下兼容的变更 |

## 版本递增规则（严格遵循 SemVer 2.0.0）

根据 SemVer 2.0.0 规范，版本号递增**必须**遵循以下规则：

### PATCH 版本号递增（Z in x.y.Z）

**必须**在以下情况递增：
- 只做了向下兼容的问题修正（fix）

**应该**在以下情况递增：
- 文档更新（docs）
- 代码风格更新（style）
- 代码重构（refactor）
- 性能优化（perf）

**可以**在以下情况递增：
- 测试相关（test）
- 构建系统或外部依赖变更（build）
- CI 配置文件和脚本变更（ci）
- 日常维护工作（chore）

**递增规则：**
- 修订号**必须**在主版本号和次版本号不变的情况下递增
- 修订号**必须**在做了向下兼容的问题修正时递增
- 修订号递增时，预发布版本号和构建元数据**应该**被忽略

### MINOR 版本号递增（Y in x.Y.z）

**必须**在以下情况递增：
- 向下兼容的功能性新增（feat）
- 任何公共 API 功能被标记为弃用时

**递增规则：**
- 次版本号**必须**在主版本号不变的情况下递增
- 次版本号递增时，修订号**必须**重置为 0
- 次版本号**可以**在包含大量新功能或改进时递增
- 次版本号递增时，预发布版本号和构建元数据**应该**被忽略

### MAJOR 版本号递增（X in X.y.z）

**必须**在以下情况递增：
- 任何不兼容的 API 修改（BREAKING CHANGE）
- 公共 API 的向下不兼容的修改

**递增规则：**
- 主版本号递增时，次版本号和修订号**必须**重置为 0
- 主版本号为零（0.y.z）时，软件处于开发初始阶段，一切都可能随时被改变
- 1.0.0 版本号用于界定公共 API 的形成
- 主版本号递增时，预发布版本号和构建元数据**应该**被忽略

### 版本递增示例

| 当前版本 | 变更类型 | 新版本 | 说明 |
|---------|---------|--------|------|
| v1.2.3 | fix | v1.2.4 | 修复问题，递增 PATCH |
| v1.2.3 | feat | v1.3.0 | 新功能，递增 MINOR，PATCH 重置为 0 |
| v1.2.3 | BREAKING CHANGE | v2.0.0 | 不兼容修改，递增 MAJOR，MINOR 和 PATCH 重置为 0 |
| v1.2.3 | docs | v1.2.4 | 文档更新，递增 PATCH |
| v1.2.3 | refactor | v1.2.4 | 代码重构，递增 PATCH |
| v0.2.3 | BREAKING CHANGE | v0.3.0 | 开发阶段，可以递增 MINOR |

## 版本发布原则（基于 SemVer 2.0.0）

### 必须遵守的原则（MUST）

1. 版本号**必须**采用 `vX.Y.Z` 格式，其中 X、Y、Z 为非负整数
2. 版本号各部分**禁止**前导零
3. 版本号**必须**单调递增
4. 一旦发布，版本内容**禁止**修改，任何修改**必须**发布为新版本
5. 主版本号递增时，次版本号和修订号**必须**重置为 0
6. 次版本号递增时，修订号**必须**重置为 0
7. 不兼容的 API 修改**必须**递增主版本号
8. 向下兼容的功能性新增**必须**递增次版本号
9. 向下兼容的问题修正**必须**递增修订号

### 应该遵守的原则（SHOULD）

1. 每次版本变更**应该**记录相应的变更类型和描述
2. 破坏性变更**应该**明确标记并在变更日志中详细说明
3. 预发布版本**应该**用于测试和验证
4. 构建元数据在判断版本优先级时**应该**被忽略
5. 版本号递增**应该**反映实际的变更程度

### 可以遵守的原则（MAY）

1. 预发布版本**可以**通过在修订号后添加连字符和标识符来表示
2. 构建元数据**可以**通过在修订号或预发布版本后添加加号和标识符来表示
3. 主版本号为零（0.y.z）的软件**可以**随时进行不兼容的修改
4. 次版本号**可以**在包含大量新功能或改进时递增

### 版本优先级规则

根据 SemVer 2.0.0 规范第 11 条，版本优先级按以下规则判断：

1. 优先级**必须**按主版本号、次版本号、修订号的数值比较来计算
2. 当主版本号、次版本号、修订号都相同时，有预发布版本的版本号优先级**低于**正式版本
3. 预发布版本的优先级按标识符从左到右比较，直到找到差异为止
4. 只有数字的标识符按数值比较
5. 有字母或连字符的标识符按 ASCII 字符顺序比较
6. 数字标识符的优先级**总是**低于非数字标识符
7. 较大的预发布版本字段集合优先级**高于**较小的字段集合

**优先级示例：**

```
v1.0.0-alpha < v1.0.0-alpha.1 < v1.0.0-alpha.beta < v1.0.0-beta < v1.0.0-beta.2 < v1.0.0-beta.11 < v1.0.0-rc.1 < v1.0.0
```


## 版本号数字限制

虽然 SemVer 2.0.0 规范没有明确规定版本号数字的上限，但为了保持版本号的可读性和语义化，本项目**必须**遵循以下限制：

### 强制限制（MUST）

为了保持版本号的可读性和语义化，版本号各部分**必须**遵循以下限制：

- **MAJOR**: 0-99（强制限制）
- **MINOR**: 0-50（强制限制）
- **PATCH**: 0-30（强制限制）

**限制说明**：
- 当 PATCH 达到 30 时，**必须**递增 MINOR 版本号并将 PATCH 重置为 0
- 当 MINOR 达到 50 时，**必须**递增 MAJOR 版本号并将 MINOR 和 PATCH 重置为 0
- 当 MAJOR 达到 99 时，**应该**重新评估项目的版本策略

**限制原因**：
1. **可读性**：较小的数字更容易记忆和识别
2. **语义化**：频繁的版本递增表明项目活跃，但过大的数字失去语义
3. **最佳实践**：遵循业界主流项目的版本号管理习惯
4. **版本规划**：强制限制促使团队更好地规划版本发布

### 警告阈值（SHOULD）

当版本号超过以下阈值时，系统**应该**发出警告：

- **PATCH > 20**: 建议尽快递增 MINOR 版本号
- **MINOR > 40**: 建议尽快递增 MAJOR 版本号
- **MAJOR > 50**: 建议重新评估版本策略

### 版本号限制示例

**符合强制限制的版本号**：
- `v1.0.0` ✅
- `v10.25.15` ✅
- `v99.50.30` ✅（达到上限）
- `v2.15.8` ✅

**超出强制限制的版本号**：
- `v100.0.0` ❌（MAJOR 超过 99）
- `v1.51.0` ❌（MINOR 超过 50）
- `v1.0.31` ❌（PATCH 超过 30）
- `v1.60.40` ❌（MINOR 和 PATCH 都超过限制）

### 数字规则

根据 SemVer 2.0.0 规范第 2 条：

1. 版本号各部分**必须**是非负整数
2. 版本号各部分**禁止**前导零
3. 版本号各部分**必须**以数值递增

**有效示例：**
- `v1.0.0` ✅
- `v10.20.30` ✅
- `v999.9999.9999` ✅（技术上有效，但不推荐）

**无效示例：**
- `v01.0.0` ❌（包含前导零）
- `v1.00.0` ❌（包含前导零）
- `v-1.0.0` ❌（负数）
- `v1.2.3.4` ❌（版本号部分过多）

## 预发布版本管理

### 预发布版本标识符

根据 SemVer 2.0.0 规范第 9 条，预发布版本**可以**通过在修订号后添加连字符和一系列点号分隔的标识符来表示：

**标准预发布标识符：**

1. **alpha** - 内部测试版本
   - 格式：`v1.0.0-alpha.1`
   - 用途：早期开发阶段，功能不完整
   - 稳定性：不稳定，可能包含严重问题

2. **beta** - 公开测试版本
   - 格式：`v1.0.0-beta.1`
   - 用途：功能基本完整，需要广泛测试
   - 稳定性：相对稳定，可能包含已知问题

3. **rc** - 候选发布版本（Release Candidate）
   - 格式：`v1.0.0-rc.1`
   - 用途：准备正式发布，最后验证
   - 稳定性：高度稳定，只修复关键问题

### 预发布版本递增规则

1. 预发布版本号**必须**从 1 开始递增
2. 预发布版本的优先级**低于**相关联的正式版本
3. 预发布版本之间的优先级按标识符比较

**预发布版本序列示例：**

```
v1.0.0-alpha.1
v1.0.0-alpha.2
v1.0.0-beta.1
v1.0.0-beta.2
v1.0.0-rc.1
v1.0.0-rc.2
v1.0.0
```

### 构建元数据

根据 SemVer 2.0.0 规范第 10 条，构建元数据**可以**通过在修订号或预发布版本后添加加号和一系列点号分隔的标识符来表示：

**构建元数据示例：**

- `v1.0.0+20130313144700` - 时间戳
- `v1.0.0+exp.sha.5114f85` - Git 提交哈希
- `v1.0.0-beta.1+exp.sha.5114f85` - 预发布版本带构建元数据

**构建元数据规则：**

1. 构建元数据在判断版本优先级时**应该**被忽略
2. 构建元数据**可以**包含任意标识符
3. 构建元数据**不影响**版本兼容性

## 版本生命周期

### 开发阶段（0.y.z）

根据 SemVer 2.0.0 规范第 4 条：

> 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。

**开发阶段规则：**

1. 主版本号为 0 时，软件处于开发初始阶段
2. 次版本号**可以**在引入不兼容变更时递增
3. 修订号**可以**在修复问题时递增
4. 公共 API **不应该**被视为稳定版

**开发阶段示例：**

```
v0.1.0 - 初始开发版本
v0.2.0 - 添加新功能（可能不兼容）
v0.2.1 - 修复问题
v0.3.0 - 重大重构（可能不兼容）
```

### 稳定阶段（1.0.0+）

根据 SemVer 2.0.0 规范第 5 条：

> 1.0.0 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的 API 时，就应该发布 1.0.0 版本。

**稳定阶段规则：**

1. 1.0.0 版本界定公共 API 的形成
2. 不兼容的 API 修改**必须**递增主版本号
3. 向下兼容的功能性新增**必须**递增次版本号
4. 向下兼容的问题修正**必须**递增修订号

**稳定阶段示例：**

```
v1.0.0 - 首个稳定版本
v1.1.0 - 添加新功能（向下兼容）
v1.1.1 - 修复问题（向下兼容）
v2.0.0 - 不兼容的 API 修改
```

## 最佳实践

### 版本发布流程

1. **开发阶段**
   - 使用 0.y.z 版本号
   - 频繁迭代，快速验证

2. **测试阶段**
   - 发布 alpha 版本进行内部测试
   - 发布 beta 版本进行公开测试
   - 发布 rc 版本进行最后验证

3. **正式发布**
   - 发布 1.0.0 版本界定公共 API
   - 严格遵循 SemVer 2.0.0 规范

4. **维护阶段**
   - 修复问题递增 PATCH 版本
   - 添加功能递增 MINOR 版本
   - 不兼容修改递增 MAJOR 版本

### 版本号选择指南

**何时递增 PATCH 版本：**
- 修复了向下兼容的问题
- 更新了文档
- 优化了性能
- 重构了代码（不影响功能）

**何时递增 MINOR 版本：**
- 添加了向下兼容的新功能
- 标记了某些功能为弃用
- 引入了大量内部改进

**何时递增 MAJOR 版本：**
- 做了不兼容的 API 修改
- 删除了已弃用的功能
- 重大架构调整

### 变更日志管理

每次版本发布**应该**记录以下信息：

1. **版本号** - 遵循 SemVer 2.0.0 格式
2. **发布日期** - ISO 8601 格式（YYYY-MM-DD）
3. **变更类型** - 使用约定式提交规范
4. **变更描述** - 清晰描述变更内容
5. **破坏性变更** - 明确标记并详细说明
6. **作者信息** - 记录变更作者

**变更日志示例：**

```markdown
## v1.2.0 - 2025-12-28

### 新增功能（feat）
- 添加用户认证功能
- 支持多语言切换

### 问题修复（fix）
- 修复登录页面样式问题
- 解决数据加载延迟

### 破坏性变更（BREAKING CHANGE）
- 无

### 作者
- 张三 (zhangsan@example.com)
```

## 常见问题

### Q1: 如何处理修订号递增过多的情况？

**A:** 根据 SemVer 2.0.0 规范，如果修订号递增超过 20 次，建议递增次版本号。这表明项目可能积累了足够多的小改进，应该作为一个新的次版本发布。

### Q2: 预发布版本如何升级到正式版本？

**A:** 预发布版本升级到正式版本时，只需移除预发布标识符即可。例如：`v1.0.0-rc.1` → `v1.0.0`

### Q3: 构建元数据何时使用？

**A:** 构建元数据用于标识特定的构建，但不影响版本优先级。常用于 CI/CD 流程中标识构建时间、提交哈希等信息。

### Q4: 如何处理已发布版本的错误？

**A:** 根据 SemVer 2.0.0 规范第 3 条，一旦发布，版本内容**禁止**修改。如果发现错误，**必须**发布新版本进行修复。

### Q5: 主版本号为 0 时如何管理版本？

**A:** 主版本号为 0 时，软件处于开发初始阶段，可以在次版本号递增时引入不兼容变更。建议在 API 稳定后发布 1.0.0 版本。

## 参考资料

- [Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html) - SemVer 官方规范
- [Conventional Commits](https://www.conventionalcommits.org/) - 约定式提交规范
- [Keep a Changelog](https://keepachangelog.com/) - 变更日志规范

## 版本历史

- **v2.1.0** (2025-12-28) - 更新为严格遵循 SemVer 2.0.0 规范
- **v2.0.0** (2025-12-13) - 添加变更类型规范和版本检查机制
- **v1.0.0** (2025-12-01) - 初始版本
